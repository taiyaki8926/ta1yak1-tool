

# This file was *autogenerated* from the file EC.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_8 = Integer(8); _sage_const_27 = Integer(27); _sage_const_9 = Integer(9); _sage_const_24 = Integer(24); _sage_const_12 = Integer(12)
import sys

def help():
    print("---Tool list---")
    print("smart(p, A, B, P, Q) -> k : Calculation of k such that Q = k*P. It is efficient when EC.order == p")
    print("pohlig(p, A, B, P, Q) -> k : It is efficient when we can get the result of factorization of P.order()")
    print("calc_A_B(p, P, Q) -> [A,B] : Calculation of coefficient A and B such that y^2 = x^3+Ax + B mod p, from two point P and Q")
    print("singular(p, A, P, Q)-> k : It is efficient when the elliptic curve is singular")


# from: https://hxp.io/blog/25/SharifCTF-2016-crypto350-British-Elevator-writeup/
def smart(p, A, B, P:list, Q:list):
    x_P, y_P = P
    x_Q, y_Q = Q
    E = EllipticCurve(GF(p), [_sage_const_0 , _sage_const_0 , _sage_const_0 , A, B])
    assert E.order() == p
    Q_p = Qp(p, _sage_const_2 )
    E_p = EllipticCurve(Q_p, [_sage_const_0 , _sage_const_0 , _sage_const_0 , A, B])
    
    yP_p = sqrt(Q_p(x_P) ** _sage_const_3  + Q_p(A) * Q_p(x_P) + Q_p(B))
    P_p = E_p(Q_p(x_P), (-yP_p, yP_p)[yP_p[_sage_const_0 ] == y_P])
    
    yQ_p = sqrt(Q_p(x_Q) ** _sage_const_3  + Q_p(A) * Q_p(x_Q) + Q_p(B))
    Q_p = E_p(Q_p(x_Q), (-yQ_p, yQ_p)[yQ_p[_sage_const_0 ] == y_Q])
    
    l_Q = E_p.formal_group().log()(- (p * Q_p)[_sage_const_0 ] // (p * Q_p)[_sage_const_1 ]) / p
    l_P = E_p.formal_group().log()(- (p * P_p)[_sage_const_0 ] // (p * P_p)[_sage_const_1 ]) / p
    e = l_Q / l_P
    assert e[_sage_const_0 ] * E(x_P, y_P) == E(x_Q, y_Q)
    return e[_sage_const_0 ]

# from: https://furutsuki.hatenablog.com/entry/2020/05/05/112207#ptr-yudai%E3%81%AE%E7%99%BA%E8%A1%A8
def pohlig(p, A, B, P:list, Q:list):
    def bsgs_add(g, h, n):
        assert _sage_const_0  * g == n * g
        m = int(sqrt(n))
        if pow(m, _sage_const_2 ) != n:
            m += _sage_const_1 
        ls = [(j * g) for j in range(m)]
        gamma = h
        for i in range(m):
            if gamma in ls:
                ret = i * m + ls.index(gamma)
                assert ret * g == h
                return ret
            else:
                gamma += (n-m) * g
        print('[+] Not Found')
        assert _sage_const_1  == _sage_const_2 
        return -_sage_const_1 

    def pohlig_prime_add(g, h, p, e):
        n = pow(p, e)
        assert _sage_const_0  * g == n * g
        x = _sage_const_0 
        gamma = pow(p, e-_sage_const_1 ) * g
        for k in range(e):
            hk = pow(p, e-_sage_const_1 -k) * ((n-x) * g + h)
            dk = bsgs_add(gamma, hk, p)
            x += pow(p, k) * dk
        assert x * g == h
        print('[+] Found discrete log {} in modulo {}^{}'.format(x, p, e))
        return x

    EC = EllipticCurve(GF(p), [A,B])
    g = EC((P[_sage_const_0 ], P[_sage_const_1 ]))
    h = EC((Q[_sage_const_0 ], Q[_sage_const_1 ]))
    n = g.order()
    assert _sage_const_0  * g == n * g
    xi_ls = []
    mod_ls = []
    f = factor(n)
    print('[+] factorize :',f)
    for p, e in list(f):
        gi = (n//pow(p, e)) * g
        hi = (n//pow(p, e)) * h
        xi_ls.append(pohlig_prime_add(gi, hi, p, e))
        mod_ls.append(pow(p, e))
        ret = crt(xi_ls, mod_ls)
        if g * ret == h:
            print('[+] Final result:', ret)
            return ret
    print('[+] Not Found')
    sys.exit()
    return -_sage_const_1 


def calc_A_B(p, P, Q):
    x1, y1 = P
    x2, y2 = Q
    a = inverse_mod(x1-x2, p) * (y1**_sage_const_2  - y2**_sage_const_2  - x1**_sage_const_3  + x2**_sage_const_3 ) % p
    b = (y1**_sage_const_2  - x1**_sage_const_3  - a*x1) % p
    try:
        EC = EllipticCurve(GF(p), [a,b])
        assert(EC.is_on_curve(x1, y1) and EC.is_on_curve(x2, y2))
    except:
        print('This may be a singular elliptic curve. Use "singular(p, A, P, Q)" function, setting A = [0, 0, 0, a, b]')
    return [a, b]

# from: https://gitlab.com/n0tsobad/ctf-writeups/tree/master/2019-02-01-nullcon/Singular
def singular(p, A:list, P, Q):
    def calc_trans(p, A):
        a1, a2, a3, a4, a6 = A
        b2 = a1**_sage_const_2  + _sage_const_4 *a2
        b4 = _sage_const_2 *a4 + a1*a3
        b6 = a3**_sage_const_2  + _sage_const_4 *a6
        b8 = a1**_sage_const_2 *a6 + _sage_const_4 *a2*a6 - a1*a3*a4 + a2*a3**_sage_const_2  - a4**_sage_const_2 
        Di = -b2**_sage_const_2 *b8 - _sage_const_8 *b4**_sage_const_3  - _sage_const_27 *b6**_sage_const_2  + _sage_const_9 *b2*b4*b6
        assert(Di % p == _sage_const_0 )
        
        r = mod((_sage_const_4 *a2 + a1**_sage_const_2 )**_sage_const_2  - _sage_const_24  * (_sage_const_2 *a4 + a1*a3), p).sqrt()
        if r == _sage_const_0 :
            x = -(_sage_const_4 *a2 + a1**_sage_const_2 ) * pow(_sage_const_12 , -_sage_const_1 , p) % p
            y = (-a1 * x - a3) * pow(_sage_const_2 , -_sage_const_1 , p) % p
            return (x, y), True
        else:
            x1 = (-(_sage_const_4 *a2 + a1**_sage_const_2 ) + r) * pow(_sage_const_12 , -_sage_const_1 , p) % p
            y1 = (-a1 * x1 - a3) * pow(_sage_const_2 , -_sage_const_1 , p) % p
            x2 = (-(_sage_const_4 *a2 + a1**_sage_const_2 ) - r) * pow(_sage_const_12 , -_sage_const_1 , p) % p
            y2 = (-a1 * x2 - a3) * pow(_sage_const_2 , -_sage_const_1 , p) % p
            return ((x1, y1), (x2, y2)), False
        
    def trans(p, A, ret, _P, _Q):
        a1, a2, a3, a4, a6 = A
        assert((a1*ret[_sage_const_1 ] - _sage_const_3 *ret[_sage_const_0 ]**_sage_const_2  - _sage_const_2 *a2*ret[_sage_const_0 ] - a4) % p == _sage_const_0 )
        assert((_sage_const_2 *ret[_sage_const_1 ] + a1*ret[_sage_const_0 ] + a3) % p == _sage_const_0 )
        P = GF(p)['x']; (x,) = P._first_ngens(1)
        y = ret[_sage_const_1 ]
        f = x**_sage_const_3  + a2*x**_sage_const_2  + a4*x + a6 - y**_sage_const_2  - a1*x*y - a3*y
        f_ = f.subs(x = x + ret[_sage_const_0 ])
        if f_.subs(x = _sage_const_0 ) != _sage_const_0 :
            print('[+] Not this ...')
            return _sage_const_0 
        else:
            r = f_.roots()
            if len(r) == _sage_const_1 :
                assert((_sage_const_0 ,_sage_const_3 ) in r)
                print('[+] This is cusp type')
                P_ = (_P[_sage_const_0 ] - ret[_sage_const_0 ], _P[_sage_const_1 ] - ret[_sage_const_1 ])
                Q_ = (_Q[_sage_const_0 ] - ret[_sage_const_0 ], _Q[_sage_const_1 ] - ret[_sage_const_1 ])
                u = P_[_sage_const_0 ] * pow(P_[_sage_const_1 ], -_sage_const_1 , p) % p
                v = Q_[_sage_const_0 ] * pow(Q_[_sage_const_1 ], -_sage_const_1 , p) % p
                return v * pow(u,-_sage_const_1 ,p) % p
            else:
                print('[+] This is node type')
                assert((_sage_const_0 ,_sage_const_2 ) in r)
                r.remove((_sage_const_0 ,_sage_const_2 ))
                P_ = (_P[_sage_const_0 ] - ret[_sage_const_0 ], _P[_sage_const_1 ] - ret[_sage_const_1 ])
                Q_ = (_Q[_sage_const_0 ] - ret[_sage_const_0 ], _Q[_sage_const_1 ] - ret[_sage_const_1 ])
                if pow(p-r[_sage_const_0 ][_sage_const_0 ], (p-_sage_const_1 )//_sage_const_2 , p) != _sage_const_1 :
                    print('[+] cannot find square root ...')
                    return _sage_const_0 
                t = GF(p)(p-r[_sage_const_0 ][_sage_const_0 ]).square_root()
                u = (P_[_sage_const_1 ] + t*P_[_sage_const_0 ]) * pow(P_[_sage_const_1 ] - t*P_[_sage_const_0 ], -_sage_const_1 , p) % p
                v = (Q_[_sage_const_1 ] + t*Q_[_sage_const_0 ]) * pow(Q_[_sage_const_1 ] - t*Q_[_sage_const_0 ], -_sage_const_1 , p) % p
                try:
                    ret = discrete_log(v, u)
                    return ret
                except:
                    print('[+] cannot find discrete log ...')
                    return _sage_const_0 
    
    def mul_singular_EC(p, A, k, P):
        def add_EC(p, A, P, Q):
            xP, yP = P
            xQ, yQ = Q
            if P != Q:
                s = (yP - yQ) * pow(xP - xQ, -_sage_const_1 , p) % p
                xR = (s**_sage_const_2  - xP - xQ) % p
                return [xR, -(yP + s * (xR - xP)) % p]
            else:
                s = (_sage_const_3  * xP**_sage_const_2  + A) * pow(_sage_const_2  * yP, -_sage_const_1 , p) % p
                xR = (s**_sage_const_2  - _sage_const_2  * xP) % p
                return [xR, -(yP + s * (xR - xP)) % p]
        _P = P
        l = int(k).bit_length()
        ls = []
        for i in range(l):
            ls.append(_P)
            _P = add_EC(p, A, _P, _P)
        init = True
        for i, _ in enumerate(bin(k)[_sage_const_2 :][::-_sage_const_1 ]):
            if _ == '1':
                if init:
                    ans = ls[i]
                    init = False
                else:
                    ans = add_EC(p, A, ans, ls[i])
        return ans
                
    ret, flag = calc_trans(p, A)
    if flag:
        print('[+] check ', ret)
        ret = trans(p, A, ret, P, Q)
        return ret
    else:
        r1, r2 = ret
        print('[+] check ', r1)
        ret = trans(p, A, r1, P, Q)
        if ret != _sage_const_0  :
            if mul_singular_EC(p, A[_sage_const_3 ], ret, P) == Q:
                print('[+] find!')
                return ret
        print('[+] check ', r2)
        ret = trans(p, A, r2, P, Q)
        if ret != _sage_const_0 :
            if mul_singular_EC(p, A[_sage_const_3 ], ret, P) == Q:
                print('[+] find!')
                return ret
    return _sage_const_0 

